<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>EDM Copilot</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="/static/images/star.ico">
  <link rel="stylesheet" href="/static/bootstrap/css/bootstrap.min.css">
  <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.5/dist/purify.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <style>
    body, html { height: 100%; margin: 0; display: flex; flex-direction: column; }
    #chat-container { flex: 1; overflow-y: auto; padding: 1rem; background-color: #f8f9fa; }
    #input-container { display: flex; padding: 1rem; border-top: 1px solid #ccc; background-color: #fff; }
    #user-input { flex: 1; margin-right: 1rem; }
    .message { margin-bottom: 1rem; }
    .message.bot { text-align: left; color: #198754; font-family: system-ui, sans-serif; line-height: 1.6; }
    .message.bot :where(h1, h2, h3, h4, h5, h6) { margin-top: 0.4rem; margin-bottom: 0.2rem; font-size: 1rem;  font-weight: 600; }
    .message.bot p { margin: 0.5rem 0; }
    .message.bot ul, .message.bot ol { padding-left: 1.5rem; margin: 0.5rem 0; }
    .message.bot li { margin-bottom: 0.25rem; }
    .message.bot a { color: #0d6efd; text-decoration: underline; }
    .message.bot em { font-style: italic; }
    .message.bot strong { font-weight: bold; }
    .message.bot pre { background-color: #f1f1f1; padding: 0.75rem; border-radius: 4px; 
                       overflow-x: auto; font-family: monospace; white-space: pre-wrap; word-wrap: -word; }
    .message bot code { background-color: #e9ecef; padding: 0.2rem 0.4rem; border-radius: 4px; font-family: monospace; }
    .message.bot .two-column { column-count: 2; column-gap: 2rem; }
    .message.bot .two-column > * { margin-bottom: 1rem; }
    .message.bot strong { cursor: pointer; text-decoration: underline; color: #198754; }
    .user { text-align: center; font-weight: bold; color: #0d6efd; background-color: #c9cccf;
            width: 100%; padding: 1rem; box-sizing: border-box; border: 2px solid #000; }
    .bot { text-align: left; color: #198754; }
    #loading-spinner { display: none; text-align: center; padding: 1rem; }
    .clickable-phrase { font-weight: bold; text-decoration: underline; cursor: pointer; color: #198754; }
    #suggested-prompts { display: flex; justify-content: center; align-items: center; min-height: 60vh; }
    .prompt-grid { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr;
                   gap: 2.5rem; width: 900px; max-width: 98vw; margin: 0 auto; }
    .prompt-btn { font-size: 1.2rem; width: '25%' !important; display: flex; flex-direction: column;
      justify-content: center; align-items: center; border-radius: 32px; box-shadow: 0 4px 24px #0002;
      text-align: center; transition: background 0.2s; background: #fff; padding: 1rem 1rem;
      white-space: normal; word-break: break-word; }
    .prompt-btn strong { font-size: 1.2rem; margin-bottom: 0.3rem; display: block; }
    .prompt-btn .prompt-text { font-size: 0.8rem; display: block; }
  </style>
</head>
<body>
  
  <div id="chat-container" class="container-fluid"></div>
  <div id="loading-spinner">
    <div class="spinner-border text-success" role="status">
      <span class="visually-hidden">Loading...</span>
    </div>
  </div>
  <div id="yaml-selector-container" style="padding: 1rem;">
    <select id="yaml-selector" class="form-select" style="width: auto; min-width: 120px; display: inline-block;"></select>
  </div>
  <div id="suggested-prompts" class="container-fluid p-2"></div>
  <div id="input-container" class="container-fluid">
    <input type="text" id="user-input" class="form-control" placeholder="Type your message..." />
    <button id="send-button" class="btn btn-primary">Send</button>
  </div>

  <script>
    const yamlFiles = {{ YAML_FILES | tojson }};
    const chatContainer = document.getElementById('chat-container');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const spinner = document.getElementById('loading-spinner');
    let conversationHistory = [];  // Changed from const to let

    function appendMessage(text, sender) {
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      if (sender === 'bot') {
        const rawHTML = DOMPurify.sanitize(marked.parse(text));
        const lineCount = rawHTML.split(/<br\s*\/?>|\n|<p>|<li>|<h[1-6]>/i).length;
        console.log('> appendMessage.lineCount', lineCount);
        const twoColDiv = document.createElement('div');
        if (lineCount > 40) {
          twoColDiv.className = 'two-column';
        }
        twoColDiv.innerHTML = rawHTML;
        messageDiv.appendChild(twoColDiv);
        messageDiv.querySelectorAll('.clickable-phrase, strong').forEach(span => {
          span.addEventListener('click', () => {
            userInput.value = span.textContent;
            sendMessage();
          });
        });
      } else if (sender === 'user') {
        // Create a container for the user's message text.
        const textSpan = document.createElement('span');
        textSpan.textContent = text;
        messageDiv.appendChild(textSpan);
      
        // Create an X button on the right-hand side.
        const removeButton = document.createElement('button');
        removeButton.textContent = 'X';
        removeButton.style.position = 'absolute';
        removeButton.style.right = '0';
        removeButton.style.top = '0';
        removeButton.style.border = 'none';
        removeButton.style.background = 'transparent';
        removeButton.style.cursor = 'pointer';
        removeButton.style.fontWeight = 'bold';
        removeButton.addEventListener('click', () => {
          // Determine the index of this user message among all user messages.
          const userMessages = Array.from(chatContainer.childNodes).filter(node => 
            node.classList.contains('message') && node.classList.contains('user')
          );
          const index = userMessages.indexOf(messageDiv);
          if (index !== -1) {
            removeLastQA(index);
          }
        });
        messageDiv.style.position = 'relative';
        messageDiv.appendChild(removeButton);
      } else {
        messageDiv.textContent = text;
      }
      chatContainer.appendChild(messageDiv);
      chatContainer.scrollTop = chatContainer.scrollHeight;
    }

    function simpleHash(conversationHistory) {
      let key = conversationHistory
        .filter((e, i) => e.role == 'user')
        .map(e => e.content)
        .join(' | ');
      let hash = 0;
      for (let i = 0; i < key.length; i++) {
        hash = ((hash << 5) - hash) + key.charCodeAt(i);
        hash |= 0;
      }
      return Math.abs(hash).toString(36).padStart(6, '0').slice(0, 6) + '-' + key.split("|").pop().replace(/:/g, "");
    }

    async function sendMessage(instructions = '') {
      const prompt = userInput.value.trim();
      if (!prompt) return;
      
      document.getElementById("yaml-selector-container").style.display = "none";
      appendMessage(prompt, 'user');
      conversationHistory.push({ role: 'user', content: prompt });
      userInput.value = '';
      spinner.style.display = 'block';
      
      let cacheKey = simpleHash(conversationHistory);
      let doFetch = true;
      
      try {
        const loadResponse = await fetch(`/load-conversation?filename=${cacheKey}`);
        if (loadResponse.ok) {
          const loaded = await loadResponse.json();
          if (loaded.data) {
            // Update conversation history by creating a new array
            conversationHistory = [...loaded.data];
            doFetch = false;
          }
        }
      } catch (e) {
        console.warn('No previous conversation found for cacheKey:', cacheKey);
      }

      if (doFetch) try {
        const response = await fetch('/send-message', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            conversation_history: conversationHistory,
            instructions: instructions
          })
        });
        
        const data = await response.json();
        if (data.error) {
          appendMessage('Error: ' + data.error, 'bot');
        } else {
          // Update conversation history by creating a new array
          conversationHistory = [...data.conversation_history];
          try {
            await fetch('/save-conversation', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ filename: cacheKey, data: conversationHistory })
            });
          } catch (e) {
            console.warn('Could not save conversation:', e);
          }
        }
      } catch (error) {
        appendMessage('Error: ' + error.message, 'bot');
      }

      appendMessage(conversationHistory[conversationHistory.length - 1].content, 'bot');
      spinner.style.display = 'none';
    }
    sendButton.addEventListener('click', sendMessage);
    userInput.addEventListener('keypress', e => {
      if (e.key === 'Enter') sendMessage();
    });

    async function loadPrompts() {
      const selector = document.getElementById('yaml-selector');
      const selectedFile = selector.value;
      const response = await fetch(`/static/${selectedFile}`);
      const yamlText = await response.text();
      const yamlData = jsyaml.load(yamlText);
      const prompts = yamlData.prompts || [];
      if (yamlData.instructions) {
        conversationHistory.length = 0;
        conversationHistory.push({ role: 'system', content: yamlData.instructions });
      }
      const container = document.getElementById('suggested-prompts');
      container.innerHTML = `
        <div style="width:100%;text-align:center;margin-bottom:2rem;">
          <h1>&nbsp;</h1>
          <h1>&nbsp;</h1>
          <h1>${yamlData.header}</h1>
          <h1>&nbsp;</h1>
          <div class="prompt-grid"></div>
          <h1>&nbsp;</h1>
          <h1>&nbsp;</h1>
        </div>
      `;
      const grid = container.querySelector('.prompt-grid');
      prompts.forEach(({ display, prompt, instructions }) => {
        if (display && prompt) {
          const button = document.createElement('button');
          button.className = 'btn btn-outline-secondary prompt-btn';
          button.innerHTML = `
            <span class="prompt-text">${display}</span>
            <span>${prompt}</span>
          `;
          button.addEventListener('click', () => {
            container.style.display = 'none'; // Hide all prompt buttons
            userInput.value = prompt.replace(/ <br> /g, ' ');
            if (instructions) instructions = instructions ? `\n\n${instructions}` : '';
            sendMessage(instructions);
          });
          grid.appendChild(button);
        }
      });
    }
    window.addEventListener('DOMContentLoaded', () => {
      // Populate the YAML dropdown from the list provided by app.py
      const yamlSelector = document.getElementById('yaml-selector');
      yamlFiles.forEach(file => {
        const option = document.createElement('option');
        option.value = file;
        option.textContent = file.replace(/_/g, ' ').replace(/\.yaml$/i, '');
        yamlSelector.appendChild(option);
      });
      // Load prompts for the initially selected file
      loadPrompts();
      yamlSelector.addEventListener('change', loadPrompts);
    });

    function removeLastQA(deleteQuestion) {
      // If deleting the first question (index 0), refresh the page
      if (deleteQuestion === 0) {
        window.location.reload();
        return;
      }

      // Remove entries from conversationHistory
      let userCount = 0;
      let startIndex = -1;
      for (let i = 0; i < conversationHistory.length; i++) {
        if (conversationHistory[i].role === 'user') {
          if (userCount === deleteQuestion) {
            startIndex = i;
            break;
          }
          userCount++;
        }
      }
      if (startIndex !== -1) {
        conversationHistory.splice(startIndex);
      }
      
      // Update chatContainer
      const pairsToKeep = deleteQuestion;
      while (chatContainer.childNodes.length > pairsToKeep * 2) {
        chatContainer.removeChild(chatContainer.lastChild);
      }
    }

    // Helper function that waits until the spinner becomes visible and then hides
    function waitForSpinnerCycle() {
      return new Promise(resolve => {
        const checkVisible = setInterval(() => {
          if (spinner.style.display === 'block') {
            clearInterval(checkVisible);
            const checkHidden = setInterval(() => {
              if (spinner.style.display === 'none') {
                clearInterval(checkHidden);
                resolve();
              }
            }, 100);
          }
        }, 100);
      });
    }

    async function doCache() {
      // Grab a static array of clickable elements.
      const clickables = Array.from(document.querySelectorAll('.clickable-phrase, .message.bot strong'));
      for (let clickable of clickables) {
        // Simulate a click on the clickable element.
        clickable.click();
        // Wait until spinner shows and then disappears.
        await waitForSpinnerCycle();
        // Determine the number of user messages (each representing one Q/A pair)
        const userMessages = conversationHistory.filter(entry => entry.role === 'user');
        const lastIndex = userMessages.length - 1;
        // Remove the last Q/A pair.
        removeLastQA(lastIndex);
      }
    }

  </script>
</body>
</html>